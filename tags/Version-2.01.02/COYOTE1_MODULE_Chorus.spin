''=======================================================================  
'' TITLE: COYOTE1_MODULE_Chorus.spin
''
'' DESCRIPTION:
''   A Chorus effect.
''   Chorus is generated by mixing the dry signal with a delayed version
''   of the input signal, and sweeping the delay tap (i.e. the length
''   of the delay) back and forth in time with an LFO (low frequency
''   oscillator).
''
''   INPUTS:
''      IN:           Audio In
''      RATE:         Controls the frequency of the LFO.
''      DEPTH:        Controls the range of time over which the delay tap
''                    sweeps.
''      +BYPASS:      Effect bypass control
''
''   OUTPUTS:
''      OUT:          Audio Out
''      +ON:          Set when effect is active (i.e. not bypassed).
''
'' COPYRIGHT:
''   Copyright (C)2008 Eric Moyer
''
'' LICENSING:
''
''   This program module is free software: you can redistribute it and/or modify
''   it under the terms of the GNU General Public License as published by
''   the Free Software Foundation, either version 3 of the License, or
''   (at your option) any later version.
''
''   This program module is distributed in the hope that it will be useful,
''   but WITHOUT ANY WARRANTY; without even the implied warranty of
''   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
''   GNU General Public License for more details.
''
''   You should have received a copy of the GNU General Public License
''   along with this program module.  If not, see <http://www.gnu.org/licenses/>.
''   
''======================================================================= 
''
''  REVISION HISTORY:
''
''  Rev    Date      Description
''  -----  --------  ---------------------------------------------------
''  1.0.0  07-19-08  Initial Release.
''  1.1.0  08-14-08  Implemented Depth control
''                   Expanded comments
''                   Deleted unused variables and data
''  1.2.0  08-17-08  Added low pass filter to the delay tap retur
''                   to filter out the high frequency "digital hiss" of
''                   jumping between non-adjacent samples.
''
''=======================================================================  
CON

  C_SRAM_BUFFER_SIZE           = 131070        'Heap requirement (128K Bytes)
  C_SRAM_SAMPLE_SIZE           = 3             'Bytes per SRAM sample  

  ' Low frequency oscillator (LFO) definitions
  LFO_PERIOD_MIN_MSEC         = 10
  LFO_PERIOD_MAX_MSEC         = 5000
      
OBJ
  hw        :       "COYOTE1_HW_Definitions.spin"  'Hardware definitions       

PUB get_module_descriptor_p
  ' Store the main RAM address of the module's code into the module descriptor. 
  long[ @_module_descriptor + hw#MDES_OFFSET__CODE_P] := @_module_entry
  ' Return a pointer to the module descriptor 
  return (@_module_descriptor)

DAT

'------------------------------------
'Module Descriptor
'------------------------------------
_module_descriptor      long    hw#MDES_FORMAT_1                                       'Module descriptor format
                        long    (@_module_descriptor_end - @_module_descriptor)        'Module descriptor size (in bytes)
                        long    (@_module_end - @_module_entry)                        'Module legth
                        long    0                                                      'Module code pointer (this is a placeholder which gets overwritten during
                                                                                       '   the get_module_descriptor_p() call) 
                        long    $01_80_00_00                                           'Module Signature
                        long    $00_01_02_00                                           'Module revision  (xx_AA_BB_CC = a.b.c)
                        long    0                                                      'Microframe requirement
                        long    C_SRAM_BUFFER_SIZE + 4                                 'SRAM requirement (heap)
                        long    0                                                      'RAM  requirement (internal propeller RAM)
                        long    0                                                      '(RESERVED0) - set to zero to ensure compatability with future OS versions
                        long    0                                                      '(RESERVED1) - set to zero to ensure compatability with future OS versions 
                        long    0                                                      '(RESERVED2) - set to zero to ensure compatability with future OS versions 
                        long    0                                                      '(RESERVED3) - set to zero to ensure compatability with future OS versions  
                        long    6                                                      'Number of sockets

                        'Socket 0
                        byte    "In",0                                                 'Socket name  
                        long    0 | hw#SOCKET_FLAG__SIGNAL | hw#SOCKET_FLAG__INPUT     'Socket flags and ID
                        byte    0  {null string}                                       'Units  
                        long    0                                                      'Range Low          
                        long    0                                                      'Range High         
                        long    0                                                      'Default Value

                        'Socket 1
                        byte    "Out",0                                                'Socket name   
                        long    1 | hw#SOCKET_FLAG__SIGNAL                             'Socket flags and ID
                        byte    0  {null string}                                       'Units  
                        long    0                                                      'Range Low          
                        long    0                                                      'Range High         
                        long    0                                                      'Default Value

                        'Socket 2
                        byte    "Rate",0                                               'Socket name 
                        long    2 | hw#SOCKET_FLAG__INPUT                              'Socket flags and ID
                        byte    "mSec",0                                               'Units  
                        long    LFO_PERIOD_MIN_MSEC                                    'Range Low
                        long    LFO_PERIOD_MAX_MSEC                                    'Range High
                        long    500                                                    'Default Value

                        'Socket 3
                        byte    "Depth",0                                              'Socket name  
                        long    3 | hw#SOCKET_FLAG__INPUT                              'Socket flags and ID
                        byte    "%",0                                                  'Units  
                        long    0                                                      'Range Low            
                        long    100                                                    'Range High
                        long    100                                                    'Default Value

                        'Socket 4
                        byte    "+Bypass",0                                            'Socket name 
                        long    4 | hw#SOCKET_FLAG__INPUT                              'Socket flags and ID
                        byte    0  {null string}                                       'Units   
                        long    0                                                      'Range Low          
                        long    1                                                      'Range High         
                        long    0                                                      'Default Value

                        'Socket 5
                        byte    "+On",0                                                'Socket name 
                        long    5                                                      'Socket flags and ID
                        byte    0  {null string}                                       'Units   
                        long    0                                                      'Range Low          
                        long    1                                                      'Range High         
                        long    1                                                      'Default Value

                        byte    "Chorus",0                                             'Module name
                        long    hw#NO_SEGMENTATION                                     'Segmentation 

_module_descriptor_end  byte    0    


DAT
                        
'------------------------------------
'Module Code 
'------------------------------------
                        org
                        
_module_entry
                        mov     p_module_control_block, PAR                     'Get pointer to Module Control Block
                        rdlong  p_system_state_block, p_module_control_block    'Get pointer to System State Block

                        'Initialize pointers into System State block
                        mov     p_ss_frame_counter, p_system_state_block
                        mov     p_ss_overrun_detect,p_system_state_block
                        add     p_ss_overrun_detect,#(hw#SS_OFFSET__OVERRUN_DETECT)  
                        mov     r1,                 p_module_control_block
                        add     r1,                 #(hw#MCB_OFFSET__HEAP_BASE_P)
                        rdlong  heap_base_address, r1

                        'Initialize pointers to the socket exhange
                        mov     p_socket_audio_in,  p_module_control_block
                        add     p_socket_audio_in,  #(hw#MCB_OFFSET__SOCKET_EXCHANGE + (0 << 2))
                        mov     p_socket_audio_out, p_module_control_block
                        add     p_socket_audio_out, #(hw#MCB_OFFSET__SOCKET_EXCHANGE + (1 << 2))
                        mov     p_socket_rate,      p_module_control_block
                        add     p_socket_rate,      #(hw#MCB_OFFSET__SOCKET_EXCHANGE + (2 << 2)) 
                        mov     p_socket_depth,     p_module_control_block
                        add     p_socket_depth,     #(hw#MCB_OFFSET__SOCKET_EXCHANGE + (3 << 2)) 
                        mov     p_socket_bypass,    p_module_control_block
                        add     p_socket_bypass,    #(hw#MCB_OFFSET__SOCKET_EXCHANGE + (4 << 2)) 
                        mov     p_socket_on,        p_module_control_block
                        add     p_socket_on,        #(hw#MCB_OFFSET__SOCKET_EXCHANGE + (5 << 2)) 

'------------------------------------
'Effect processing loop
'------------------------------------

                        '------------------------------------
                        'Init
                        '------------------------------------
                        mov     sram_p_in, heap_base_address
                        mov     pending_audio_out, #0
                        mov     filtered_sample, #0

                        'Set MEMBUS interface as outputs
                        or      dira, PINGROUP__MEM_INTERFACE

                        'Clear SRAM
                        mov     sram_data, #0
                        mov     sram_address, heap_base_address

_lock1                  lockset hw#LOCK_ID__MEMBUS   wc
              if_c      jmp     #_lock1
              
                        call    #_sram_write
                        mov     r2, SRAM_BUFFER_SIZE
                                     
_clear_loop             call    #_sram_burst_write
                        sub     r2, #C_SRAM_SAMPLE_SIZE  wc                    
              if_nc     jmp     #_clear_loop
                        lockclr hw#LOCK_ID__MEMBUS  

                        '------------------------------------
                        'Sync
                        '------------------------------------
                        rdlong  previous_microframe, p_ss_frame_counter         'Initialize previous microframe
                        
                        'Wait for the beginning of a new microframe
_frame_sync             rdlong  current_microframe, p_ss_frame_counter
                        cmp     previous_microframe, current_microframe  wz
              if_z      jmp     #_frame_sync                                    'If current_microframe = previoius_microframe

                        'Verify sync, and report an overrun condition if it has occurred.
                        '
                        'NOTE: An overrun condition is reported to the OS by writing a non-zero value to the "overrun detect" field in the
                        '      SYSTEM_STATE block.  The code below writes the value of current_microframe in order to conserve code space,
                        '      achieve portability, and limit execution time. That value will be non-zero 99.9999999767169% of the time,
                        '      which is sufficiently reliable for overrun reporting
                        '
                        add     previous_microframe, #1
                        cmp     previous_microframe, current_microframe  wz
              if_nz     wrlong  current_microframe, p_ss_overrun_detect
                        
                        mov     previous_microframe, current_microframe         'previous_microframe = current_microframe

                        '------------------------------------
                        'Get audio in sample and write audio out sample
                        '------------------------------------
                        wrlong  pending_audio_out, p_socket_audio_out         
                        rdlong  audio_in_sample, p_socket_audio_in
                        
                        '------------------------------------
                        'Bypass
                        '------------------------------------
                        'Read bypass state
                        rdlong  r1, p_socket_bypass  
                        cmp     SIGNAL_TRUE, r1   wc, wz

                        'Update on/off indication
        if_c_or_z       mov     r2, 0
        if_nc_and_nz    mov     r2, SIGNAL_TRUE
                        wrlong  r2, p_socket_on
                        
                        'If bypassed, then just pass audio through 
        if_c_or_z       mov     pending_audio_out, audio_in_sample 
        if_c_or_z       jmp     #_frame_sync


                        '------------------------------------
                        'Generate LFO (Low Frequeency Oscillator)
                        '------------------------------------

                        'Read the RATE socket and use the value to determine the angular step per sample
                        rdlong  x, p_socket_rate
                        shr     x, #21
                        add     x, #1
                        mov     y, LFO_PERIOD_RANGE
                        call    #_mult
                        shr     y, #10
                        add     y, #LFO_PERIOD_MIN_MSEC

                        mov     x, LFO_CALCULATION_NUMERATOR
                        call    #_div19
                        and     x, QUOTIENT_MASK                                ' x now contains the 16.16 Fixed point angular step

                        'Increment the LFO angle and calculate the sin
                        add     angle_16_16_fxp, x                              ' Increment the current angle, based on LFO rate
                        mov     sin, angle_16_16_fxp
                        shr     sin, #16                                        ' Convert from 16.16 fixed point angle to integer angle (where $1fff = 360 degrees)
                        call    #_getsin                                        ' Get the sin of the angle (returned in sin, as a signed value)
                        add     sin, HALF_MAX                                   ' Convert result to a 17 bit positive integer
                        shr     sin, #1                                         ' Shift result one bit to get a 16 bit positive integer

                        'Now generate the chorus depth (in audio samples)
                        mov     x, sin                                          ' x = sin
                        rdlong  y, p_socket_depth                               ' y = *p_socket_depth;
                        shr     y, #16                                          ' y >>= 16;                  
                        call    #_mult                                          ' y = y * x;
                        shr     y, #23                                          ' y >>= 23;
                        add     y, FIXED_DELAY                                  ' y += FIXED_DELAY;

                        '------------------------------------
                        'Read delay tap
                        '------------------------------------
 
                        'Calculate the tap delay in bytes (3 bytes per sample are stored in SRAM)
                        mov     r1, y                                           ' r1 = y * 3;
                        shl     r1, #1                                          '
                        add     r1, y                                           '

                        'Calculate the sram address of the tap
                        mov     sram_address, sram_p_in 
                        sub     sram_address, r1                 wc             'sram_address -= r1
                  if_nc sub     sram_address, heap_base_address  wc, nr         'if ((sram_address < heap_base_address) || (sram_address < 0))               
                  if_c  add     sram_address, SRAM_BUFFER_SIZE                  '   sram_address += C_SRAM_BUFFER_SIZE

                        'Read the sample at the tap location from SRAM
_lock2                  lockset hw#LOCK_ID__MEMBUS   wc
                   if_c jmp     #_lock2
                        call    #_sram_read
                        lockclr hw#LOCK_ID__MEMBUS

                        '------------------------------------
                        'Apply low-pass filter to value read at delay tap
                        '------------------------------------
                        ' Note: this removes the digital hiss which results fro hopping between non-adjacent samples
                        '
                        mov     x, sram_data
                        sub     x, filtered_sample
                        mov     y, #9
                        
                        'Signed divide
                        test    x, SIGN_BIT  wz
                 if_nz  neg     x, x
                        shr     x, #16
                        call    #_div19
                        and     x, QUOTIENT_MASK
                        shl     x, #16
                 if_nz  neg     x, x

                        adds    filtered_sample, x

                        '------------------------------------
                        'Sum the current signal and the (low pass filtered) delay tap signal
                        '------------------------------------
                        'Get the current incoming audio sample fromm the audio input socket
                        mov     r2, audio_in_sample

                        'Sum the delayed and the current samples
                        adds    r2, filtered_sample
                        
                        '------------------------------------ 
                        'Store output                         
                        '------------------------------------ 
                        mov     pending_audio_out, r2
                        
                        'Save current audio sample to SRAM
                        mov     sram_data, audio_in_sample
                        mov     sram_address, sram_p_in
_lock3                  lockset hw#LOCK_ID__MEMBUS   wc
                   if_c jmp     #_lock3
                        call    #_sram_write
                        lockclr hw#LOCK_ID__MEMBUS   
                        
                        'Increment the SRAM pointer, with wrap-around to the start of the buffer
                        add      sram_p_in, #C_SRAM_SAMPLE_SIZE                 ' sram_p_in += C_SRAM_SAMPLE_SIZE;
                        mov      r1, heap_base_address                          ' r1 = heap_base_address 
                        add      r1, SRAM_BUFFER_SIZE                           ' r1 += SRAM_BUFFER_SIZE        // r1 now points one byte past the end of the buffer
                        cmp      r1, sram_p_in  wc, wz                          ' if(sram_p_in >= r1){
                   if_c mov      sram_p_in, heap_base_address                   '   sram_p_in = heap_base_address;
                                                                                ' }

                        'Done Echo
                        jmp     #_frame_sync


'------------------------------------
'MEMBUS Read
'------------------------------------
_sram_read
                        or      dira, PINGROUP__MEMBUS
                        
                        'Write HIGH address
                        mov     r1, sram_address
                        and     r1, PINGROUP__MEMBUS
                        andn    outa, PINGROUP__MEMBUS
                        or      outa, r1

                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__SET_ADDR_HIGH

                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK

                        'Write MID address
                        mov     r1, sram_address
                        shl     r1, #8
                        and     r1, PINGROUP__MEMBUS   
                        andn    outa, PINGROUP__MEMBUS
                        or      outa, r1

                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__SET_ADDR_MID

                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK

                        'Write LOW address
                        mov     r1, sram_address
                        shl     r1, #16
                        and     r1, PINGROUP__MEMBUS   
                        andn    outa, PINGROUP__MEMBUS
                        or      outa, r1

                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__SET_ADDR_LOW

                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK

                        'Setup Read
                        andn    dira, PINGROUP__MEMBUS

                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__READ_BYTE

                        'Clear data longword
                        mov     sram_data, #0

                        'Read HIGH byte
                        or      outa, PIN__MEMBUS_CLK
                        mov     sram_data, ina
                        andn    outa, PIN__MEMBUS_CLK
                        and     sram_data, PINGROUP__MEMBUS
                        
                        'Read MID byte
                        or      outa, PIN__MEMBUS_CLK
                        mov     r1, ina
                        andn    outa, PIN__MEMBUS_CLK
                        and     r1, PINGROUP__MEMBUS  
                        shr     r1, #8
                        or      sram_data, r1

                        'Read Low byte
                        or      outa, PIN__MEMBUS_CLK
                        mov     r1, ina
                        andn    outa, PIN__MEMBUS_CLK
                        and     r1, PINGROUP__MEMBUS 
                        shr     r1, #16
                        or      sram_data, r1

                        'convert 24 bit word to 32 bit word
                        shl     sram_data, #8

                        andn    outa, PINGROUP__MEM_INTERFACE
_sram_read_ret          ret
                        
                         
'------------------------------------
'MEMBUS Write
'------------------------------------
_sram_write

                        or      dira, PINGROUP__MEMBUS
                        
                        'Write HIGH address
                        mov     r1, sram_address
                        and     r1, PINGROUP__MEMBUS
                        andn    outa, PINGROUP__MEMBUS
                        or      outa, r1

                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__SET_ADDR_HIGH

                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK

                        'Write MID address
                        mov     r1, sram_address
                        shl     r1, #8
                        and     r1, PINGROUP__MEMBUS  
                        andn    outa, PINGROUP__MEMBUS
                        or      outa, r1

                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__SET_ADDR_MID

                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK

                        'Write LOW address
                        mov     r1, sram_address
                        shl     r1, #16
                        and     r1, PINGROUP__MEMBUS
                        andn    outa, PINGROUP__MEMBUS
                        or      outa, r1

                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__SET_ADDR_LOW

                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK
                        
_sram_burst_write
                      
                        'Setup Write
                        andn    outa, PINGROUP__MEMBUS_CNTL
                        or      outa, #hw#MEMBUS_CNTL__WRITE_BYTE

                        'Write HIGH byte
                        mov     r1, sram_data
                        shr     r1, #8
                        and     r1, PINGROUP__MEMBUS
                        andn    outa, PINGROUP__MEMBUS   
                        or      outa, r1
                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK
                        
                        'Write MID byte
                        mov     r1, sram_data
                        and     r1, PINGROUP__MEMBUS
                        andn    outa, PINGROUP__MEMBUS   
                        or      outa, r1
                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK

                        'Write Low byte
                        mov     r1, sram_data
                        shl     r1, #8
                        and     r1, PINGROUP__MEMBUS
                        andn    outa, PINGROUP__MEMBUS   
                        or      outa, r1
                        or      outa, PIN__MEMBUS_CLK
                        andn    outa, PIN__MEMBUS_CLK

                        andn    outa, PINGROUP__MEM_INTERFACE
                        andn    dira, PINGROUP__MEMBUS 
_sram_burst_write_ret                        
_sram_write_ret         ret                               

'------------------------------------ 
' Get sine/cosine
'
'       quadrant:    1            2            3            4
'          angle:    $0000..$07FF $0800..$0FFF $1000..$17FF $1800..$1FFF
'    table index:    $0000..$07FF $0800..$0001 $0000..$07FF $0800..$0001
'         mirror:    +offset      -offset      +offset      -offset
'           flip:    +sample      +sample      -sample      -sample
'
' on entry: sin[12..0] holds angle (0° to just under 360°)
' on exit: sin holds signed value ranging from $0000FFFF ('1') to
' $FFFF0001 ('-1')
'------------------------------------ 
_getcos                 add     sin,sin_90      'for cosine, add 90°
_getsin                 test    sin,sin_90 wc   'get quadrant 2|4 into c
                        test    sin,sin_180 wz  'get quadrant 3|4 into nz
                        negc    sin,sin         'if quadrant 2|4, negate offset
                        or      sin,sin_table   'or in sin table address >> 1
                        shl     sin,#1          'shift left to get final word address
                        rdword  sin,sin         'read word sample from $E000 to $F000
                        negnz   sin,sin         'if quadrant 3|4, negate sample
_getsin_ret
_getcos_ret             ret                     '39..54 clocks
                                                '(variance due to HUB sync on RDWORD)
sin_90                  long    $0800
sin_180                 long    $1000
sin_table               long    $E000 >> 1      'sine table base shifted right
sin                     long    0                                                

'------------------------------------
'16x16 Multiply                                    
'------------------------------------
' Multiply x[15..0] by y[15..0] (y[31..16] must be 0)
' on exit, product in y[31..0]
'------------------------------------
_mult                   shl x,#16               'get multiplicand into x[31..16]
                        mov t,#16               'ready for 16 multiplier bits
                        shr y,#1 wc             'get initial multiplier bit into c
                        
_mult_loop              if_c add y,x wc         'conditionally add multiplicand into product
                        rcr y,#1 wc             'get next multiplier bit into c.
                                                ' while shift product
                        djnz t,#_mult_loop      'loop until done
_mult_ret               ret                     'return with product in y[31..0] 

'------------------------------------
'19-Bit Divide (19 bit quotient, 13 bit denominator)
'------------------------------------
' Divide x[31..0] by y[12..0] (y[13] must be 0)
' on exit, quotient is in x[18..0] and remainder is in x[31..19]
'------------------------------------  
_div19                  shl y,#18               'get divisor into y[30..18]
                        mov t,#19               'ready for 19 quotient bits
                        
_div19_loop             cmpsub x,y wc           'if y =< x then subtract it, set C
                        rcl x,#1                'rotate c into quotient, shift dividend 
                        djnz t,#_div19_loop     'loop until done
                        
_div19_ret              ret                     'quotient in x[18..0], rem. in x[31..19]

'------------------------------------
'Initialized Data                                      
'------------------------------------
LFO_PERIOD_RANGE            long  LFO_PERIOD_MAX_MSEC -  LFO_PERIOD_MIN_MSEC
LFO_CALCULATION_NUMERATOR   long  $00BA2E8B
                                  'NOTE: This value is equavalent to the calculation: hw#MSEC_PER_SEC * hw#ANG_360 * hw#INT_TO_FXP_16_16 / hw#AUDIO_SAMPLE_RATE,
                                  '      but the IDE compiler does not have sufficient numerical resolution to evaluate it without overflowing, so it
                                  '      has been expressed as a pre-evaluated constant.
                                  
SRAM_BUFFER_SIZE        long   C_SRAM_BUFFER_SIZE

PINGROUP__MEM_INTERFACE long   hw#PINGROUP__MEM_INTERFACE
PINGROUP__MEMBUS        long   hw#PINGROUP__MEMBUS
PINGROUP__MEMBUS_CNTL   long   hw#PINGROUP__MEMBUS_CNTL 
PIN__MEMBUS_CLK         long   hw#PIN__MEMBUS_CLK
HALF_MAX                long   $FFFF
WORD_MASK               long   $0000ffff
QUOTIENT_MASK           long   $0007ffff        'Divide returns 19 bit quotient
FIXED_DELAY             long   1320             'Approximaty 30msec, in 44k samples
SIGNAL_TRUE             long   $40000000        'True/False threshold of socket values
SIGN_BIT                long   $80000000                         

'------------------------------------
'Module End                                      
'------------------------------------

'NOTE:  This label is used in the module descriptor data table to calculate the total length of the module's code.
'       It is critical that this label appear AFTER all initialized data, otherwise some initialized data will be
'       lost when modules are saved/restored in OpenStomp Workbench, or converted into Dynamic modules.
_module_end             long   0

'------------------------------------
'Uninitialized Data
'------------------------------------
                          
r1                        res     1             ' General purpose register
r2                        res     1             ' General purpose register
sram_address              res     1             ' SRAM address (used for SRAM reads / writes)
sram_data                 res     1             ' SRAM data (used for SRAM reads / writes)

angle_16_16_fxp           res     1             ' Fixed point 16.16 angle (used for LFO calculation)

x                         res     1             ' Used for multiply and divide operations
y                         res     1             ' Used for multiply and divide operations  
t                         res     1             ' Used for multiply and divide operations  

p_system_state_block      res     1             ' Pointer to System State block
p_module_control_block    res     1             ' Pointer to Module Control block
p_ss_overrun_detect       res     1             ' Pointer to Overrun Detect field in the System State block
p_ss_frame_counter        res     1             ' Pointer to the frame counter
  
p_socket_audio_in         res     1             ' Pointer to audio input socket
p_socket_audio_out        res     1             ' Pointer to audio output socket
p_socket_rate             res     1             ' Pointer to rate socket
p_socket_depth            res     1             ' Pointer to depth socket
p_socket_bypass           res     1             ' Pointer to depth socket
p_socket_on               res     1             ' Pointer to on socket

previous_microframe       res     1             ' Value of the previous microframe counter
current_microframe        res     1             ' Value of the current microframe counter

audio_in_sample           res     1             ' Audio input sample value
sram_p_in                 res     1             ' Pointer to SRAM location where incoming sample will be stored
heap_base_address         res     1             ' Pointer to base of allocated SRAM block
pending_audio_out         res     1
filtered_sample           res     1

                          fit                 